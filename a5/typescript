Script started on Fri 05 Apr 2019 08:52:31 PM MDT
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5> ls -al
total 20
drwxr-xr-x  5 msmit474 students 4096 Apr  5 20:52 [0m[01;34m.[0m
drwxr-xr-x 11 msmit474 students 4096 Apr  5 20:36 [01;34m..[0m
drwxr-xr-x  2 msmit474 students 4096 Apr  5 20:46 [01;34mp1[0m
drwxr-xr-x  2 msmit474 students 4096 Apr  5 20:49 [01;34mp2[0m
drwxr-xr-x  2 msmit474 students 4096 Apr  5 20:51 [01;34mp3[0m
-rw-r--r--  1 msmit474 students    0 Apr  5 20:52 typescript
[m[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5> cd p1
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p1> ls -al
total 40
drwxr-xr-x 2 msmit474 students  4096 Apr  5 20:46 [0m[01;34m.[0m
drwxr-xr-x 5 msmit474 students  4096 Apr  5 20:52 [01;34m..[0m
-rw-r--r-- 1 msmit474 students   129 Apr  5 20:39 globals.h
-rw-r--r-- 1 msmit474 students  2683 Apr  5 20:39 Grid.cpp
-rw-r--r-- 1 msmit474 students   408 Apr  5 20:38 Grid.h
-rw-r--r-- 1 msmit474 students   758 Apr  5 20:46 makefile
-rw-r--r-- 1 msmit474 students   743 Apr  5 20:37 makefile~
-rw-r--r-- 1 msmit474 students 11299 Apr  5 20:38 test_Grid.cpp
[m[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p1> cat makefile
TARGET=Grid
TESTS=test_Grid
MODULES=Grid.o
TESTMODULES=test_Grid.o Grid.o
CPPFLAGS=-ansi -pedantic-errors -Wall -Wconversion
GCOV_COMP=-fprofile-arcs -ftest-coverage
GCOV_LINK=-lgcov --coverage
GTFLAGS=-lgtest -lpthread -lgtest_main


$(TARGET): clean $(MODULES)
	g++ $(CPPFLAGS) $(MODULES) -g -o $(TARGET)

$(TESTS): clean coveredGrid test_Grid.o
	g++ $(GCOV_LINK) $(GTFLAGS) $(TESTMODULES) -g -o $(TESTS)
	$(TESTS)
	gcov $(TARGET).cpp 2> /dev/null | grep -A 1 $(TARGET).cpp

clean:
	/bin/rm -f *.o *.*~ *.g* $(TESTS) $(TARGET)

$(TESTS).o: $(TESTS).cpp
	g++ $(CPPFLAGS) $(GTFLAGS) -g -c $(TESTS).cpp

Grid.o: $(TARGET).cpp
	g++ $(CPPFLAGS) -g -c $(TARGET).cpp

coveredGrid: $(TARGET).cpp Grid.h
	g++ $(CPPFLAGS) $(GTFLAGS) $(GCOV_COMP) -g -c $(TARGET).cpp
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p1> cat test_Grid.cpp
#include <iostream>
using namespace std;
#include <sstream>
#include <string>
#include "Grid.h"
#include <gtest/gtest.h>


class GridTests : public testing::Test
{
protected:
  virtual void SetUp()
  {
  }

  virtual void TearDown()
  {
  }
 
  Grid c;

};


TEST_F(GridTests, DefaultConstructorTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  c.write(actualOutput);
  EXPECT_EQ(expected, actualOutput.str());
}

TEST_F(GridTests, plotPointTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "*                                                 \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  c.plot_point(0,0);
  c.write(actualOutput);

  EXPECT_EQ(expected, actualOutput.str());

}

TEST_F(GridTests, plotVerticalLineTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "--------------------------------------------------\n";

  c.plot_line(0,0, 0,14);
  c.write(actualOutput);

  EXPECT_EQ(expected, actualOutput.str());

}

TEST_F(GridTests, plotHorizontalLineTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "**************************************************\n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  c.plot_line(0,0, 49,0);
  c.write(actualOutput);

  EXPECT_EQ(expected, actualOutput.str());

}

TEST_F(GridTests, plotNegativeVerticalLineTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "*                                                 \n";
  expected += "--------------------------------------------------\n";

  c.plot_line(0,14, 0,0);
  c.write(actualOutput);

  EXPECT_EQ(expected, actualOutput.str());

}

TEST_F(GridTests, plotNegativeHorizontalLineTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "**************************************************\n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  c.plot_line(49,0, 0,0);
  c.write(actualOutput);

  EXPECT_EQ(expected, actualOutput.str());

}

TEST_F(GridTests, plotDiagonalLineTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "*                                                 \n";
  expected += " *                                                \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  c.plot_line(0,0, 1,1);
  c.write(actualOutput);

  EXPECT_EQ(expected, actualOutput.str());

}

TEST_F(GridTests, OveridenOperatorTest)
{
  stringstream actualOutput;
  string expected = "";

  expected += "--------------------------------------------------\n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  c.write(actualOutput);
  EXPECT_EQ(expected, actualOutput.str());
}
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p1> make test_Grid
/bin/rm -f *.o *.*~ *.g* test_Grid Grid
g++ -ansi -pedantic-errors -Wall -Wconversion -lgtest -lpthread -lgtest_main -fprofile-arcs -ftest-coverage -g -c Grid.cpp
g++ -ansi -pedantic-errors -Wall -Wconversion -lgtest -lpthread -lgtest_main -g -c test_Grid.cpp
g++ -lgcov --coverage -lgtest -lpthread -lgtest_main test_Grid.o Grid.o -g -o test_Grid
test_Grid
Running main() from gtest_main.cc
[==========] Running 8 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 8 tests from GridTests
[ RUN      ] GridTests.DefaultConstructorTest
[       OK ] GridTests.DefaultConstructorTest (1 ms)
[ RUN      ] GridTests.plotPointTest
[       OK ] GridTests.plotPointTest (0 ms)
[ RUN      ] GridTests.plotVerticalLineTest
[       OK ] GridTests.plotVerticalLineTest (0 ms)
[ RUN      ] GridTests.plotHorizontalLineTest
[       OK ] GridTests.plotHorizontalLineTest (0 ms)
[ RUN      ] GridTests.plotNegativeVerticalLineTest
[       OK ] GridTests.plotNegativeVerticalLineTest (0 ms)
[ RUN      ] GridTests.plotNegativeHorizontalLineTest
[       OK ] GridTests.plotNegativeHorizontalLineTest (0 ms)
[ RUN      ] GridTests.plotDiagonalLineTest
[       OK ] GridTests.plotDiagonalLineTest (0 ms)
[ RUN      ] GridTests.OveridenOperatorTest
[       OK ] GridTests.OveridenOperatorTest (0 ms)
[----------] 8 tests from GridTests (1 ms total)

[----------] Global test environment tear-down
[==========] 8 tests from 1 test case ran. (1 ms total)
[  PASSED  ] 8 tests.
gcov Grid.cpp 2> /dev/null | grep -A 1 Grid.cpp
File 'Grid.cpp'
Lines executed:95.38% of 65
Grid.cpp:creating 'Grid.cpp.gcov'

[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p1> cd ../p2
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> ls -al
total 56
drwxr-xr-x 2 msmit474 students 4096 Apr  5 20:49 [0m[01;34m.[0m
drwxr-xr-x 5 msmit474 students 4096 Apr  5 20:52 [01;34m..[0m
-rw-r--r-- 1 msmit474 students  129 Apr  5 20:40 globals.h
-rw-r--r-- 1 msmit474 students 2683 Apr  5 20:40 Grid.cpp
-rw-r--r-- 1 msmit474 students  408 Apr  5 20:40 Grid.h
-rw-r--r-- 1 msmit474 students 1951 Apr  5 20:49 makefile
-rw-r--r-- 1 msmit474 students 1915 Apr  5 20:39 makefile~
-rw-r--r-- 1 msmit474 students 8014 Apr  5 20:41 Shape_Collection.cpp
-rw-r--r-- 1 msmit474 students 3271 Apr  5 20:40 Shape_Collection.h
-rw-r--r-- 1 msmit474 students 3202 Apr  5 20:41 Shape.cpp
-rw-r--r-- 1 msmit474 students  572 Apr  5 20:41 Shape.h
-rw-r--r-- 1 msmit474 students 3117 Apr  5 20:39 test_Shape_Collection.cpp
-rw-r--r-- 1 msmit474 students 3091 Apr  5 20:39 test_Shape.cpp
[m[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat makefile
TARGET=Grid
TESTS=test_Grid test_Shape test_Shape_Collection
MODULES=Grid.o
GRIDTESTMODULES=test_Grid.o Grid.o 
SHAPETESTMODULES=test_Shape.o Shape.o Grid.o
SHAPECOLLECTIONTESTMODULES=test_Shape_Collection.o Shape_Collection.o Shape.o Grid.o
CPPFLAGS=-ansi -pedantic-errors -Wall -Wconversion
GCOV_COMP=-fprofile-arcs -ftest-coverage
GCOV_LINK=-lgcov --coverage
GTFLAGS=-lgtest -lpthread -lgtest_main


$(TARGET): clean $(MODULES)
	g++ $(CPPFLAGS) $(MODULES) -g -o $(TARGET)

test_Grid: clean coveredGrid test_Grid.o
	g++ $(GCOV_LINK) $(GTFLAGS) $(GRIDTESTMODULES) -g -o test_Grid
	test_Grid
	gcov Grid.cpp 2> /dev/null | grep -A 1 Grid.cpp

test_Shape: clean coveredShape test_Shape.o Grid.o
	g++ $(GCOV_LINK) $(GTFLAGS) $(SHAPETESTMODULES) -g -o test_Shape
	test_Shape
	gcov Shape.cpp 2> /dev/null | grep -A 1 Shape.cpp

test_Shape_Collection: clean coveredShape_Collection test_Shape_Collection.o Shape.o Grid.o
	g++ $(GCOV_LINK) $(GTFLAGS) $(SHAPECOLLECTIONTESTMODULES) -g -o test_Shape_Collection
	test_Shape_Collection
	gcov Shape_Collection.cpp 2> /dev/null | grep -A 1 Shape_Collection.cpp

clean:
	/bin/rm -f *.o *.*~ *.g* $(TESTS) $(TARGET)

test_Grid.o: test_Grid.cpp Grid.h
	g++ $(CPPFLAGS) $(GTFLAGS) -g -c test_Grid.cpp

Grid.o: Grid.cpp Grid.h globals.h
	g++ $(CPPFLAGS) -g -c Grid.cpp

coveredGrid: Grid.cpp Grid.h
	g++ $(CPPFLAGS) $(GTFLAGS) $(GCOV_COMP) -g -c $(TARGET).cpp

test_Shape.o: test_Shape.cpp
	g++ $(CPPFLAGS) $(GTFLAGS) -g -c test_Shape.cpp

Shape.o: Shape.cpp
	g++ $(CPPFLAGS) -c Shape.cpp

coveredShape: Shape.cpp Shape.h
	g++ $(CPPFLAGS) $(GTFLAGS) $(GCOV_COMP) -g -c Shape.cpp

test_Shape_Collection.o: test_Shape_Collection.cpp
	g++ $(CPPFLAGS) $(GTFLAGS) -g -c test_Shape_Collection.cpp

Shape_Collection.o: Shape_Collection.cpp Shape.h
	g++ $(CPPFLAGS) -g -c Shape_Collection.cpp

coveredShape_Collection: Shape_Collection.cpp Shape_Collection.h
	g++ $(CPPFLAGS) $(GTFLAGS) $(GCOV_COMP) -g -c Shape_Collection.cpp
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat test_Shape.cpp
#include <iostream>
using namespace std;
#include <sstream>
#include <string>
#include "Grid.h"
#include "Shape.h"
#include <gtest/gtest.h>


class ShapeTests : public testing::Test
{
protected:
  virtual void SetUp()
  {
  }

  virtual void TearDown()
  {
  }
 
    Grid c;

};


TEST_F(ShapeTests, MoveTest)
{
  stringstream actualOutput;
  string expected = "";
  Shape square(0,0,5);

  expected += "--------------------------------------------------\n";
  expected += "    *****                                         \n";
  expected += "    *   *                                         \n";
  expected += "    *   *                                         \n";
  expected += "    *   *                                         \n";
  expected += "    *****                                         \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  square.move(4,0);
  square.draw(c);
  c.write(actualOutput);
  EXPECT_EQ(expected, actualOutput.str()); 
}

TEST_F(ShapeTests, DefaultConstructorTest)
{
  stringstream actualOutput;
  string expected = "";
  Shape square(0,0,5);

  expected += "--------------------------------------------------\n";
  expected += "*****                                             \n";
  expected += "*   *                                             \n";
  expected += "*   *                                             \n";
  expected += "*   *                                             \n";
  expected += "*****                                             \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "                                                  \n";
  expected += "--------------------------------------------------\n";

  square.draw(c);
  c.write(actualOutput);
  EXPECT_EQ(expected, actualOutput.str());
}
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat Shape.h
#ifndef SHAPE
#define SHAPE

#include "Grid.h"

/*

  Name: Matthew Smith
  MRU E-mail:  msmit474@mtroyal.ca
  Course:      COMP 1633-001
  Assignment:  5 part 2
  Due Date:    Friday, April 5, 2019 at 11:59 p.m.
  Instructor:  Paul Pospisil

  Source File: Shape.h

 */

class Shape
{
public:
    Shape(int lft, int up, int width);

    void move(int new_left, int new_upper);

    void draw(Grid& grid);

protected:
    void get_bounding_box(int& lft, int& up, int& rght, int& low) const;

private:
    int left;
    int upper;
    int right;
    int lower;

};

#endif
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat Shape.cpp
#include "Shape.h"
#include "Grid.h"

/*

  Name: Matthew Smith
  MRU E-mail:  msmit474@mtroyal.ca
  Course:      COMP 1633-001
  Assignment:  5 part 2
  Due Date:    Friday, April 5, 2019 at 11:59 p.m.
  Instructor:  Paul Pospisil

  Source File: Shape.cpp

 */
/*********************************************************************
 *
 *  CLASS: Shape
 *
 *  PURPOSE: A group of positions for a shape on a grid
 *
 *
 *  PRIVATE DATA MEMBERS:
 *
 *  left - The leftmost position of the shape
 *  
 *  upper - The upmost position of the shape
 *
 *  right - The rightmost position of the shape
 *
 *  lower - The lowest position of the shape
 *
 *********************************************************************/

/*********************************************************************
 *
 *  FUNCTION: Shape
 *
 *  PURPOSE: initializes a shape to the specified size.
 *
 *  INPUT: lft - the left position of the shape
 *         up - the upper position of the shape
 *         width - the width of the shape
 *
 *********************************************************************/

Shape :: Shape(int lft, int up, int width)
{
    left = lft;
    upper = up;
    right = (lft + width) - 1;
    lower = (up + width) - 1;
}

/*********************************************************************
 *
 *  FUNCTION: draw
 *
 *  PURPOSE: draw the shape to the given Grid
 *
 *  METHOD: - uses the plot_line function to create the lines
 *            based on the position of the shape
 *
 *  INPUT: grid - a grid that will be drawn to 
 *
 *  OUTPUT: grid - the grid that has been drawn to
 *
 *********************************************************************/

void Shape :: draw(Grid& grid)
{
    grid.plot_line(left,upper, right,upper);       // Top line
    grid.plot_line(left,upper, left,lower);        // Left line
    grid.plot_line(left,lower, right,lower);       // Bottom line
    grid.plot_line(right,upper, right,lower);      // Right line
}

/*********************************************************************
 *
 *  FUNCTION: move
 *
 *  PURPOSE: moves the shape to a new position on the grid
 *
 *  METHOD: - calculates the width of the shape 
 *          - assigns the new positions
 *
 *  INPUT: new_left - the new leftmost position of the shape
 *         new_upper - the new upper position of the shape
 *
 *********************************************************************/

void Shape :: move(int new_left, int new_upper)
{
    int width;
    width = right - left;

    left = new_left;
    upper = new_upper;
    right = left + width;
    lower = upper + width;

}

/*********************************************************************
 *
 *  FUNCTION: get_bounding_box
 *
 *  PURPOSE: gets the postion of the shape on the Grid
 *
 *  METHOD: - assigns the passed vales to the corresponding data members 
 *          
 *  INPUT:  - integers that will be assigned to the position of the shape
 *
 *  RETURNS: - the position values of the shape
 *
 *********************************************************************/

void Shape :: get_bounding_box(int& lft, int& up, int& rght, int& low) const
{
    lft = left;
    up = upper;
    rght = right;
    low = lower;
}
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat test_Shape_Collection.cpp
#include <iostream>
using namespace std;
#include <sstream>
#include <string>
#include "Grid.h"
#include "Shape.h"
#include "Shape_Collection.h"
#include <gtest/gtest.h>


class Shape_CollectionTests : public testing::Test
{
protected:
  virtual void SetUp()
  {
  }

  virtual void TearDown()
  {
  }
 
    Grid c;

};

TEST_F(Shape_CollectionTests, WriteNamesTest)
{
    Shape_Collection myShapes;
    stringstream actualOutput;
    string expected = "";

    myShapes.write_names(actualOutput);

    EXPECT_EQ(expected, actualOutput.str());
}

TEST_F(Shape_CollectionTests, AddTest)
{
    Shape_Collection myShapes;
    stringstream actualOutput;
    string expected = "s2, s1";
    Shape* shapePtr = new Shape(0,0,5); 

    myShapes.add(shapePtr, "s1");
    shapePtr = new Shape(0,6,5);       
    myShapes.add(shapePtr, "s2");
    myShapes.write_names(actualOutput);

    EXPECT_EQ(expected, actualOutput.str());
}

TEST_F(Shape_CollectionTests, DrawShapesTest)
{
    Shape_Collection myShapes;
    stringstream actualOutput;
    string expected = "";
    Shape* shapePtr = new Shape(0,0,5); 


    expected += "--------------------------------------------------\n";
    expected += "*****                                             \n";
    expected += "*   *                                             \n";
    expected += "*   *                                             \n";
    expected += "*   *                                             \n";
    expected += "*****                                             \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "                                                  \n";
    expected += "--------------------------------------------------\n";


    myShapes.add(shapePtr, "s1");
    myShapes.draw_shapes(actualOutput);

    EXPECT_EQ(expected, actualOutput.str());
}

TEST_F(Shape_CollectionTests, RemoveTest)         // not a very effective test
{
    Shape_Collection myShapes;
    stringstream actualOutput;
    string expected = "s1";
    Shape* shapePtr = new Shape(0,0,5); 

    myShapes.add(shapePtr, "s1");
    shapePtr = new Shape(0,6,5);
    myShapes.add(shapePtr, "s2");
    myShapes.remove("s2");
    myShapes.write_names(actualOutput);

    EXPECT_EQ(expected, actualOutput.str());
}

TEST_F(Shape_CollectionTests, LookupTest)
{
    Shape_Collection myShapes;
    Shape* shapePtr = new Shape(0,0,5); 
    Shape* actual;

    myShapes.add(shapePtr, "s1");
    actual = myShapes.lookup("s2");

    EXPECT_EQ(NULL, actual);
}
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat Shape_Collection.h
#ifndef SHAPE_COLLECTION
#define SHAPE_COLLECTION

#include <string>

using namespace std;

#include "Shape.h"

/*********************************************************************
 *
 *  CLASS: Shape_Collection
 *
 *  PURPOSE: A collection of pointers to shape objects.
 *           The order of elements is irrelevant.
 * 
 *  Each shape is associated with a name used for lookup and removal.
 *  The shapes are assumed to have been dynamically allocated from the 
 *  heap by the client.
 *  The collection takes custody of these shapes, and therefore it will 
 *  deallocate them as necessary.
 *
 *  ASSUMPTIONS: 
 *  1. The client never adds duplicate shape pointers
 *  2. The client never adds a shape under an already-existing name
 *
 *********************************************************************
 *
 *  PUBLIC METHODS:
 *
 *********************************************************************
 *
 *  Shape_Collection
 *         PURPOSE: initializes an empty collection
 *
 *********************************************************************
 *
 *  ~Shape_Collection
 *         PURPOSE: deallocates all shape objects
 *
 *********************************************************************
 *
 *  add
 *         PURPOSE: adds the given shape pointer to the collection,
 *                  associating it with the given name.
 *
 *         INPUT: shape - a pointer to a dynamically allocated shape
 *                name  - the name to associated with the shape
 *
 *********************************************************************
 *
 *  remove
 *
 *         PURPOSE: removes the named shape from the collection, if it
 *                  exists.  The shape object is deallocated.
 *
 *         INPUT: name - the name of the shape to remove
 *
 *********************************************************************
 *
 *  lookup
 *
 *         PURPOSE: retrieves the pointer to the named shape
 *
 *         INPUT: name - the name of the shape to look up
 *
 *         RETURNS: the pointer, or NULL if no such shape
 *
 *********************************************************************
 *
 *  draw_shapes
 *
 *         PURPOSE: renders all shapes in the collection
 *
 *         INPUT: out - the output stream to use
 *
 *         OUTUPT: out - the output stream has been written to
 *
 *********************************************************************
 *
 *  write_names
 *
 *         PURPOSE: writes the list of shape names in the collection
 *
 *         INPUT: out - the output stream to use
 *
 *         OUTPUT: out - the output stream has been written to
 *
 *********************************************************************/


class Shape_Collection
{
public:
   Shape_Collection ();
   ~Shape_Collection ();

   void add (Shape* shape, string name);
   void remove (string name);

   Shape* lookup (string name) const;

   void draw_shapes (ostream& out) const;
   void write_names (ostream& out) const;

private:
   struct Node
   {
      Node* next;
      Node* prev;

      Shape* shape;
      string name;
   };

   Shape_Collection (const Shape_Collection& orig);
   Shape_Collection& operator= (const Shape_Collection& rhs);

   void remove_all ();
   Node* lookup_node (string name) const;
   Node* head;
};


#endif
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> cat Shape_Collection.cpp
#include "Shape_Collection.h"

/*

  Name: Matthew Smith
  MRU E-mail:  msmit474@mtroyal.ca
  Course:      COMP 1633-001
  Assignment:  5 part 2
  Due Date:    Friday, April 5, 2019 at 11:59 p.m.
  Instructor:  Paul Pospisil

  Source File: Shape_Collection.cpp

 */
/*********************************************************************
 *
 *  CLASS: Shape_Collection
 *
 *  PURPOSE: A collection of pointers to shape objects.
 *           The order of elements is irrelevant.
 *
 *  PRIVATE DATA MEMBERS:
 *
 *  head - a pointer to the head node of a doubly linked list, NULL if
 *         the list is empty
 *
 *  NOTES:
 *  Each node contains:
 *
 *       - a pointer to the "next" node, NULL for tail node
 *
 *       - a pointer to the "prev" (previous) node, NULL for head node
 *
 *       - shape: a pointer to a dynamically allocated shape object
 *
 *       - name: the name associated with that shape
 *
 *  The list is doubly linked to simplify the implementation of "remove".
 *  The "lookup_node" helper function returns a pointer to a node.  
 *  Therefore, "remove" can simply take this node, unlink it from its 
 *  "prev" and "next" neighbours (if any), and then deallocate.
 *
 *********************************************************************/

/*********************************************************************
 *
 *  FUNCTION: Shape_Collection
 *
 *  PURPOSE: initializes an empty collection.
 *
 *********************************************************************/

Shape_Collection :: Shape_Collection () : head (NULL)
{
}


/*********************************************************************
 *
 *  FUNCTION: ~Shape_Collection
 *
 *  PURPOSE: deallocates all dynamically allocated
 *           memory by removing all nodes.
 *
 *********************************************************************/

Shape_Collection :: ~Shape_Collection ()
{
   while (head != NULL)
      remove(head->name);
}


/*********************************************************************
 *
 *  FUNCTION: add
 *
 *  PURPOSE: adds the given shape pointer to the collection,
 *           associating it with the given name.
 *
 *  METHOD: - allocate the node
 *          - link it in at the front of the list
 *          - store the shape pointer and name inside
 *
 *  INPUT: shape - a pointer to a dynamically allocated shape
 *         name  - the name to associated with the shape
 *
 *********************************************************************/

void Shape_Collection :: add (Shape* shape, string name)
{
   Node* new_node = new Node;

   new_node->next = head;
   new_node->prev = NULL;
   new_node->shape = shape;
   new_node->name = name;

   if (head != NULL)
     head->prev = new_node;

   head = new_node;
}

/*********************************************************************
 *
 *  FUNCTION: remove
 *
 *  PURPOSE: removes the named shape from the collection, if it exists.
 *           The shape object is deallocated.
 *
 *  METHOD: - look up the node
 *          - if it exists:
 *               - if it has a successor, set successor's 
 *                 predecessor to by-pass this node
 *               - if it has a predecessor, set predecessor's
 *                 successor to by-pass this node
 *               - if it has no predecessor (i.e. it was at the
 *                 front of the list) update the head pointer
 *               - deallocate the shape object
 *               - deallocate the node
 *
 *  INPUT: name - the name of the shape to remove
 *
 *********************************************************************/

void Shape_Collection :: remove (string name)
{
   Node* gone = lookup_node (name);

   if (gone != NULL)
   {
      if (gone->next != NULL)
         gone->next->prev = gone->prev;
   
      if (gone->prev != NULL)
         gone->prev->next = gone->next;
      else
         head = gone->next;

      delete gone->shape;
      delete gone;
   }
}


/*********************************************************************
 *
 *  FUNCTION: lookup
 *
 *  PURPOSE: retrieves the pointer to the named shape
 *
 *  INPUT: name - the name of the shape to look up
 *
 *  RETURNS: the pointer, or NULL if no such shape
 *
 *********************************************************************/

Shape* Shape_Collection :: lookup (string name) const
{
   Shape* found = NULL;
   Node* gotit = lookup_node(name);

   if (gotit != NULL)
      found = gotit->shape;

   return found;
}

/*********************************************************************
 *
 *  FUNCTION: draw_shapes
 *
 *  PURPOSE: draws all the shapes in the collection to the screen
 *           
 *
 *  METHOD: - instantiates a grid object
 *          - create a temporary pointer and make equal to head
 *          - goes through the list starting at the head:
 *               - draws the shape at the current node to the grid
 *          - write the grid to the output stream
 *          
 *  INPUT: out - the output stream that will be written to
 *
 *  OUTPUT: out - the output stream that has been written to
 *
 *********************************************************************/

void Shape_Collection :: draw_shapes (ostream& out) const
{
    Grid grid;
    Node* temp = head;

    while(temp != NULL)
    {
	temp->shape->draw(grid);

	temp = temp->next;
    }

    grid.write(out);             
    

}

/*********************************************************************
 *
 *  FUNCTION: draw_shapes
 *
 *  PURPOSE: draws all the shapes in the collection to the screen
 *           
 *
 *  METHOD: - create a temporary pointer and make equal to head
 *          - goes through the list starting at the head:
 *               - write the name of the shape at the current node to the stream
 *               - if the list has more nodes, prints a comma
 *          
 *  INPUT: out - the output stream that will be written to
 *
 *  OUTPUT: out - the output stream that has been written to
 *
 *********************************************************************/

void Shape_Collection :: write_names (ostream& out) const
{
    Node* temp = head;

    while(temp != NULL)
    {
                                       // Might need square brackets
	out << temp->name;

	if(temp->next != NULL)
	{
	    out << ", ";
	}

	temp = temp->next;
    }

}

/*********************************************************************

 *********************************************************************/

Shape_Collection :: Shape_Collection (const Shape_Collection& orig)
{
  // DUMMY IMPLEMENTATION - NOT CALLABLE FROM CLIENT
}


/*********************************************************************

 *********************************************************************/

Shape_Collection& Shape_Collection :: operator = (const Shape_Collection& rhs)
{
  // DUMMY IMPLEMENTATION - NOT CALLABLE FROM CLIENT
  return *this;
}


/*********************************************************************
 *
 *  FUNCTION: lookup_node
 *
 *  PURPOSE: looks up the node with the given name
 *
 *  METHOD: sequential search algorithm
 *
 *  INPUT: name - the name of the shape to look up
 *
 *  RETURNS: a pointer to the node containing the named shape, NULL
 *           if not found
 *
 *  REMARKS:
 *      Node is defined in the private data area of the Shape_Collection
 *      class. As a consequence, when it is returned directly, its 
 *      "location" must be resolved by using the scope operator as a
 *      prefix
 *      i.e.  return type of Shape_Collection::Node*
 *            says "you can find this definition in
 *            the Shape_Collection class"
 *********************************************************************/

Shape_Collection::Node* Shape_Collection :: lookup_node (string name) const
{
   bool found = false;
   Node* curr = head;

   while (!found && curr != NULL)
   {
      if (curr->name == name)            // can use with C++ string class
         found = true;
      else
         curr = curr->next;
   }
   return curr;
}
[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> make test_Shape
/bin/rm -f *.o *.*~ *.g* test_Grid test_Shape test_Shape_Collection Grid
g++ -ansi -pedantic-errors -Wall -Wconversion -lgtest -lpthread -lgtest_main -fprofile-arcs -ftest-coverage -g -c Shape.cpp
g++ -ansi -pedantic-errors -Wall -Wconversion -lgtest -lpthread -lgtest_main -g -c test_Shape.cpp
g++ -ansi -pedantic-errors -Wall -Wconversion -g -c Grid.cpp
g++ -lgcov --coverage -lgtest -lpthread -lgtest_main test_Shape.o Shape.o Grid.o -g -o test_Shape
test_Shape
Running main() from gtest_main.cc
[==========] Running 2 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 2 tests from ShapeTests
[ RUN      ] ShapeTests.MoveTest
[       OK ] ShapeTests.MoveTest (0 ms)
[ RUN      ] ShapeTests.DefaultConstructorTest
[       OK ] ShapeTests.DefaultConstructorTest (0 ms)
[----------] 2 tests from ShapeTests (0 ms total)

[----------] Global test environment tear-down
[==========] 2 tests from 1 test case ran. (0 ms total)
[  PASSED  ] 2 tests.
gcov Shape.cpp 2> /dev/null | grep -A 1 Shape.cpp
File 'Shape.cpp'
Lines executed:80.00% of 25
Shape.cpp:creating 'Shape.cpp.gcov'

[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> make test_Shape_Collection
/bin/rm -f *.o *.*~ *.g* test_Grid test_Shape test_Shape_Collection Grid
g++ -ansi -pedantic-errors -Wall -Wconversion -lgtest -lpthread -lgtest_main -fprofile-arcs -ftest-coverage -g -c Shape_Collection.cpp
g++ -ansi -pedantic-errors -Wall -Wconversion -lgtest -lpthread -lgtest_main -g -c test_Shape_Collection.cpp
g++ -ansi -pedantic-errors -Wall -Wconversion -c Shape.cpp
g++ -ansi -pedantic-errors -Wall -Wconversion -g -c Grid.cpp
g++ -lgcov --coverage -lgtest -lpthread -lgtest_main test_Shape_Collection.o Shape_Collection.o Shape.o Grid.o -g -o test_Shape_Collection
test_Shape_Collection
Running main() from gtest_main.cc
[==========] Running 5 tests from 1 test case.
[----------] Global test environment set-up.
[----------] 5 tests from Shape_CollectionTests
[ RUN      ] Shape_CollectionTests.WriteNamesTest
[       OK ] Shape_CollectionTests.WriteNamesTest (0 ms)
[ RUN      ] Shape_CollectionTests.AddTest
[       OK ] Shape_CollectionTests.AddTest (0 ms)
[ RUN      ] Shape_CollectionTests.DrawShapesTest
[       OK ] Shape_CollectionTests.DrawShapesTest (0 ms)
[ RUN      ] Shape_CollectionTests.RemoveTest
[       OK ] Shape_CollectionTests.RemoveTest (0 ms)
[ RUN      ] Shape_CollectionTests.LookupTest
[       OK ] Shape_CollectionTests.LookupTest (0 ms)
[----------] 5 tests from Shape_CollectionTests (0 ms total)

[----------] Global test environment tear-down
[==========] 5 tests from 1 test case ran. (1 ms total)
[  PASSED  ] 5 tests.
gcov Shape_Collection.cpp 2> /dev/null | grep -A 1 Shape_Collection.cpp
File 'Shape_Collection.cpp'
Lines executed:90.32% of 62
Shape_Collection.cpp:creating 'Shape_Collection.cpp.gcov'

[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> [K[msmit474@ins.mtroyal.ca ~/1633/assignments/asg5/p2> exit
exit

Script done on Fri 05 Apr 2019 08:56:41 PM MDT
